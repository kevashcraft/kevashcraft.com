{% extends 'templates/master.twig' %}

{% set title = 'Setup Puppet 5' %}

{% set canonical = url ~ '/puppet-5/setup/' %}
{% set logo = url ~ '/img/common/puppet-logo.svg' %}
{% set logo_png = url ~ '/img/common/puppet-logo.png' %}

{% set description = 'How to a setup Puppet 5 Linux Module to configure users, packages, and services.' %}

{% block content %}
<section>
  <h3><a href="{{ canonical }}" title="Setup Puppet 5">Setup Puppet 5</a></h3>
  <div class="flex">
    <div>
      <img src="{{ logo }}" width="150px">
    </div>
    <div class="stretch">
      <p>
        <a href="https://puppet.com/docs/puppet/5.3/index.html" target="_blank" rel="noopener" title="Puppet Reference Manual">Puppet</a> is a server management tool used to automatically configure users, services, and more. It's fairly easy to setup and takes the guesswork out of server configuration, giving you an authority to reference for the current state of your machines as well as a central location to update everything at once.
      </p>
      <p>
        In this tutorial we'll walk through <a href="#intro-to-puppet">an introduction to Puppet</a>, how to <a href="#install-puppet">install Puppet server</a>, and then setting up the <a href="#site-manifest">site manifest</a>, <a href="#hieradata">hieradata</a>, an example module to <a href="#linux-module">configure linux packages and users</a>, an example module to <a href="#httpd-module">configure an apache web server</a>, and then some <a href="#best-practices">best practices</a>.
      </p>
    </div>
  </div>
  <div class="indent">
    <h5>Tutorial Overview</h5>
    <ul>
      <li>
        <a href="#intro-to-puppet">Puppet Intro</a>
      </li>
      <li>
        <a href="#install-puppet">Install Puppet</a>
      </li>
      <li>
        <a href="#site-manifest">Site Manifest</a>
      </li>
      <li>
        <a href="#hieradata">Hieradata</a>
      </li>
      <li>
        <a href="#linux-module">Linux Module</a>
      </li>
      <li>
        <a href="#httpd-module">Httpd Module</a>
      </to>
      <li>
        <a href="#best-practices">Best Practices</a>
      </li>
    </ul>
  </div>
</section>
<section id="intro-to-puppet">
  <h4><a href="#intro-to-puppet">Puppet Intro</a></h4>
  <p>
    Have you ever learned something new and then wanted to implement it across all of your servers, like <a href="https://mozilla.github.io/server-side-tls/ssl-config-generator/" target="_blank" rel="noopener" title="Mozille SSL Configuration Generator">SSL Best Practices</a>, <a href="http://localhost:8000/centos-7.4/basic-configuration/#ssh-access" target="_blank" rel="noopener" title="KA: Lockdown SSH Server">hardening an SSH server</a>, or maybe just <a href="http://localhost:8000/centos-7.4/basic-configuration/#motd-message" target="_blank" rel="noopener" title="KA: Add Message of the Day">updating the motd</a>? Or have you ever wondered what state you left the firewall in 6 months ago the last time you were working on a box? Or have you ever gotten tired of using a handful of scripts to maintain more servers than you can count? That's why I like puppet.
  </p>
  <p>
    Puppet provides one location for all of your user passwords, default packages, virtual host configurations, cron jobs, everything. And, best yet, if you keep your puppet config revision controlled then you always have control over the state of your servers, including the ability to rollback configuration changes.
  </p>
  <p>
    Puppet consists of Puppet Server running on one machine, and Puppet Agent running on all of the others. The agents can be configured to automatically retrieve new changes, or manually with a trigger. All of the communication is encrypted and certificates (automatically generated by puppet) are used to ensure the server and agents are known. The only open port is 8140 on the master.
  </p>
  <div class="snippet">
    <p class="filename">Directory Structure</p>
    <p class="note">/etc/puppetlabs/code/environments/production</p>
    <pre>
./manifests/site.pp  <span>#list of hosts and their roles</span>

./data/common.yaml   <span>#default configuration values</span>
./data/nodes/        <span>#host-specific config values</span>

./modules/           <span>#custom modules</span>
./modules/$module/manifests/init.pp   <span>#module entry point</span>
./modules/$module/files/              <span>#static files</span>
./modules/$module/templates/          <span>#template files</span>
    </pre>
  </div>
</section>
<section id="install-puppet">
  <h4><a href="#install-puppet">Install Pupppet Server</a></h4>
  <p>
    To install Puppet 5, add the official repo and then use your package manager.
  </p>
  <div class="snippet">
    <p>Install Puppet on CentOS 7</p>
    <pre>
rpm -Uvh https://yum.puppet.com/puppet5/puppet5-release-el-7.noarch.rpm
yum install puppetserver -y
systemctl start puppetserver
systemctl enable puppetserver
    </pre>
  </div>
  <div class="snippet">
    <p>Install Puppet on Ubuntu 16.04</p>
    <pre>
wget https://apt.puppetlabs.com/puppet5-release-xenial.deb
dpkg -i puppet5-release-xenial.deb
apt update
apt install puppetserver
    </pre>
  </div>
  <p>
    Here's a <a href="https://puppet.com/docs/puppet/5.3/puppet_platform.html" target="_blank" rel="noopener" title="Puppet Installation Instructions">list of all of the Official Puppet Repositories</a> for other operating systems.
  </p>
  <div class="snippet">
    <p>Set PATH for /opt/puppetlabs/bin</p>
    <pre>
echo 'export PATH=/opt/puppetlabs/bin:$PATH' >> ~/.bashrc
export PATH=/opt/puppetlabs/bin:$PATH
    </pre>
  </div>
</section>
<section id="site-manifest">
  <h4><a href="#site-manifest">Site Manifest</a></h4>
  <p>
    Let's begin with the <span class="command">site.pp</span> which defines the hosts and the corresponding modules to apply to each.
  </p>
  <div class="snippet">
    <p class="filename">./manifests/site.pp</p>
    <pre>
node default {
  include linux
}

node 'webserver.example.com' {
  include linux
  include httpd
}
    </pre>
  </div>
  <p>
    Here we're stating that every undefined node should have the linux module applied to it and the `webserver.example.com` host should get both the linux and httpd modules.
  </p>
  <p>
    You could also use '*' as a wildcard to define hosts so `webserver.*` would work as well as the explicit hostname.
  </p>
</section>
<section id="hieradata">
  <h4><a href="#hieradata">Hieradata</a></h4>
  <p>
    Hieradata is the recommended way to define the variables used by Puppet modules. We'll start with the <span class="command">hiera.yaml</span> file which defines how Puppet loads the rest of the data.
  </p>
  <div class="snippet">
    <p class="filename">./hiera.yaml</p>
    <pre>
---
version: 5
defaults:
  datadir: data
  data_hash: yaml_data
hierarchy:
  - name: "Per-node data (yaml version)"
    path: "nodes/%{::trusted.certname}.yaml"
  - name: "Other YAML hierarchy levels"
    paths:
      - "common.yaml"
    </pre>
  </div>
  <p>
    This states that we'll be using the yaml file format, the data will be stored in ./data, and it will be loaded by first checking if a node-specific file exists (such as ./data/nodes/webserver.example.com.yaml) and if not then loading the ./data/common.yaml file.
  </p>
  <p>
    Next we'll look at an example common.yaml file.
  </p>
  <div class="snippet">
    <p class="filename">./data/common.yaml</p>
    <pre>
linux::root_pw: '$1$xyz$LeL/QNMIaRT9H99RmIsgy/'
linux::nameserver: 8.8.8.8
    </pre>
  </div>
  <div class="snippet">
    <p class="filename">Generate Linux Password Hash</p>
    <pre>
openssl passwd -1 -salt xyz
    </pre>
  </div>
  <p>
    This defines the root_pw and nameserver arguments for the linux module.
  </p>
  <p>
    Before we move on let's look at one more example that demonstrates an advantage of using the yaml format. We can define variables once and then reuse them, which comes in handy as your configurations grow.
  </p>
  <div class="snippet">
    <p class="filename">./data/common.yaml</p>
    <pre>
global::root_pw: &global_root_pw
  '$1$xyz$LeL/QNMIaRT9H99RmIsgy/'
global::nameserver: &global_nameserver
  8.8.8.8
linux::root_pw: *global_root_pw
linux::nameserver: *global_nameserver
    </pre>
  </div>
  <p>
    Here we've first defined the root_pw and nameserver variables, including an &identifier next to them which we're able to use later.
  </p>
</section>
<section id="linux-module">
  <h4><a href="#linux-module">An Example Linux Module</a></h4>
  <p>
    A Puppet Module is a group of configuration parameters which can include Packages to install, Services to start, Files to copy, and Users to create.
  </p>
  <p>
    To get started, go to <span class="command">./modules</span> and run <span class="command">puppet module generate $USER-linux</span>. The generation script will create the essential files needed for the module. Most of the files created are for metadata, tests, and documentation. We'll focus on <span class="command">manifests/init.pp</span> as it contains the module definition.
  </p>
  <p>
    Let's look at the basic structure of the module class first.
  </p>
  <div class="snippet">
    <p class="filename">./manifests/init.pp</p>
    <pre>
class linux (
  // arguments
) {
  // actions
}
    </pre>
  </div>
  <p>
    The argument values will be coming from the hieradata and the actions are Puppet actions such as <span class="command">user</span>, <span class="command">package</span>, <span class="command">service</span>, and <span class="command">file</span>. Ruby can be used to work with the arguments to combine or loop through arrays, create conditional statements, etc.
  </p>
  <p>
    Let's create a basic class to set the root user's password.
  </p>
  <div class="snippet">
    <p class="filename">./manifests/init.pp</p>
    <pre>
class linux (
  String $root_pw
) {
  user { 'root':
    ensure   => present,
    password => $root_pw
  }
}
    </pre>
  </div>
  <p>
    That's easy enough, right? We've added a String argument that will be coming from the hieradata, and used the <span class="command">user</span> definition to tell Puppet that this user should 1) exist, and 2) have the given password. If either of those conditions are not met, Puppet will remedy the situation.
  </p>
  <p>
    The structure of a definition is as follows:
  </p>
  <div class="snippet">
    <p>Module Statement Syntax</p>
    <pre>
type { subject:
  parameter => value
}
    </pre>
  </div>
  <p>
    Let's add the ability to install a package to this module.
  </p>
  <div class="snippet">
    <p class="filename">./manifests/init.pp</p>
    <pre>
class linux (
  String $root_pw
) {
  user { 'root':
    ensure   => present,
    password => $root_pw
  }

  package { 'vim-enhanced':
    ensure => present
  }
}
    </pre>
  </div>
  <p>
    Again, we're stating the type (<span class="command">package</span>), and then telling Puppet to ensure it's present. If it's not already present, then it'll be installed.
  </p>
  <p>
    Next let's add the apache package and enable it as a service.
  </p>
  <div class="snippet">
    <p class="filename">./manifests/init.pp</p>
    <pre>
class linux (
  String $root_pw
) {
  user { 'root':
    ensure   => present,
    password => $root_pw
  }

  package { 'vim-enhanced':
    ensure => present
  }

  package { 'httpd':
    ensure => present
  }

  service { 'httpd':
    ensure => running,
    enable => true
  }
}
    </pre>
  </div>
  <p>
    There we've added the httpd package and then told Puppet to ensure that it's both running and enabled.
  </p>
  <p>
    But what if we're not on a Red Hat system and apache goes by a different name? Those commands would fail. So let's update the module with some conditional statements to ensure that it'll work on Debian systems as well.
  </p>
  <div class="snippet">
    <p class="filename">./manifests/init.pp</p>
    <pre>
class linux (
  String $root_pw
) {
  user { 'root':
    ensure   => present,
    password => $root_pw
  }

  $vim = $::osfamily == 'redhat' ? 'vim-enhanced' : 'vim'

  package { $vim:
    ensure => present
  }

  $apache = $::osfamily == 'debian' ? 'apache2' : 'httpd'

  package { $apache:
    ensure => present
  }

  service { $apache:
    ensure => running,
    enable => true
  }
}
    </pre>
  </div>
  <p>
    There we've added two ternary expressions to set both the vim and apache package names. You could also use a switch if you wanted to check for additional options.
  </p>
  <p>
    The <span class="command">$::osfamily</span> fact is a global variable in Puppet that contains, wait for it, the os family. Others are also available such as <span class="command">$::operatingsystem</span> and more.
  </p>
  <p>
    Okay, we're about there. Let's do two more things with this module. First let's make sure a file is present.
  </p>
  <p>
    For simplicities sake we're going to empty out this module example and start fresh.
  </p>
  <div class="snippet">
    <p class="filename">./manifests/init.pp</p>
    <pre>
class linux () {
  file { '/etc/resolv.conf':
    source => 'puppet://modules/linux/resolv.conf'
  }
}
    </pre>
  </div>
  <p>
    That will ensure that the file ./modules/linux/resolv.conf on the Puppet server also exists at /etc/resolv.conf on the client.
  </p>
  <p>
    Then to include a non-static file, we'd use a template.
  </p>
  <div class="snippet">
    <p class="filename">./manifests/init.pp</p>
    <pre>
class linux ( String $nameserver ) {
  file { '/etc/resolv.conf':
    content => template('linux/resolv.conf.erb')
  }
}
    </pre>
  </div>
  <div class="snippet">
    <p class="filename">./modules/linux/templates/resolv.conf.erb</p>
{% verbatim %}
    <pre>
nameserver <%= @nameserver %>
    </pre>
{% endverbatim %}
  </div>
  <p>
    That will pass the $nameserver argument to the resolv.conf.erb template file and render it to /etc/resolv.conf on the client.
  </p>
  <p>
    Those are the basics for creating a module.
  </p>
</section>
<section id="httpd-module">
  <h4><a href="#httpd-module">An Example Httpd Module</a></h4>
  <p>
    Next we'll look through an httpd module. To begin, we'll add the following to the common.yaml file.
  </p>
  <div class="snippet">
    <p class="filename">./hieradata/common.yaml</p>
    <pre>
httpd::admin_email: webmaster@example.com
httpd::docroot: /srv
httpd::listen_on: 10.17.0.7
httpd::maint_user: kevin
httpd::sites:
  - domain: www.example.com
    aliases:
      - example.com
    docroot: /srv/example.com/www/dist
    ssl: example.com
  - domain: blog.example.com
    aliases:
      - www.blog.example.com
    docroot: /srv/example.com/blog/dist
    ssl: example.com
  - domain: tutorials.example.com
    aliases:
      - www.tutorials.example.com
    docroot: /srv/example.com/tutorials/dist
    ssl: example.com
    </pre>
  </div>
  <p>
    Here we've defined the admin_email, docroot, maint_user, and listen_on variables as well as an array of sites.
  </p>
  <div class="snippet">
    <p class="filename">./modules/httpd/manifests/init.pp</p>
    <pre>
class httpd (
  $sites,
  $admin_email,
  $maint_user,
  $docroot,
  $listen_on,
  ) {

  case $::osfamily {
    'debian': {
      $httpd = 'apache2'
      $httpd_user = 'http'
      $letsencrypt = 'certbot'
    }
    'redhat': {
      $httpd = 'httpd'
      $httpd_user = 'apache'
      $letsencrypt = 'certbot'

      package { 'mod_ssl':
        ensure  => installed,
        require => Package[$httpd],
      }
    }
    default: {
      $httpd = 'httpd'
      $httpd_user = 'apache'
      $letsencrypt = 'letsencrypt'
    }
  }

  package { $httpd:
    ensure => installed,
  }

  package { $letsencrypt:
    ensure  => installed,
    require => Package[$httpd],
  }

  service { $httpd:
    ensure     => running,
    enable     => true,
    hasrestart => true,
    hasstatus  => true,
    require    => Package[$httpd],
  }

  file { "/etc/$httpd/conf/httpd.conf":
    content => template('httpd/httpd.conf.erb'),
    notify  => Service['httpd'],
  }

  file { "/etc/$httpd/conf.d":
    ensure => directory,
  }

  file { $docroot:
    ensure  => directory,
    owner   => $maint_user,
    group   => $httpd_user,
    selrole => 'object_r',
    seluser => 'system_u',
    seltype => 'httpd_sys_content_t',
  }

  $sites.each |$index, $site| {
    file { "/etc/httpd/conf.d/${index}-${site['domain']}.conf":
      content => template('httpd/virtual_host.conf.erb'),
      notify  => Service['httpd'],
      require => File['/etc/httpd/conf.d'],
    }
  }
}
    </pre>
  </div>
  <p>
    Walking through this module, we're first setting the package named with the <span class="command">case $::osfamily</span> switch, setting the name of the webserver package, user and group, as well as installing mod_ssl if we're on a redhat system.
  </p>
  <p>
    Next we're installing the webserver package, and then the letsencrypt package.
  </p>
  <p>
    After that we're enabling the webserver service. Note that we've included arguments for <span class="command">require</span> to make sure that the package is installed before we attempt to start the service. We've also told Puppet that this service has the ability to restart and a status check to assist whenever it needs to be checked or restarted.
  </p>
  <p>
    Next we're setting up the master configuration file, httpd.conf. This is being populated by the httpd.conf.erb file.
  </p>
  <div class="snippet">
    <p class="filename">./modules/httpd/manifests/init.pp partial</p>
    <pre>
file { "/etc/$httpd/conf/httpd.conf":
  content => template('httpd/httpd.conf.erb'),
  notify  => Service['httpd'],
}
    </pre>
  </div>
  <p>
    Then we're ensuring that the root web directory exists with the proper owner and roles.
  </p>
  <div class="snippet">
    <p class="filename">./modules/httpd/manifests/init.pp partial</p>
    <pre>
file { $docroot:
  ensure  => directory,
  owner   => $maint_user,
  group   => $httpd_user,
  selrole => 'object_r',
  seluser => 'system_u',
  seltype => 'httpd_sys_content_t',
}
    </pre>
  </div>
  <p>
    And finally we're creating the virtual host config files. Note here that we've added the <span class="command">notify</span> parameter which will restart the service any time one of the config files changes, as well as the <span class="command">require</span> param to ensure this is all done after the conf.d directory is created.
  </p>
  <div class="snippet">
    <p class="filename">./modules/httpd/manifests/init.pp partial</p>
    <pre>
  $sites.each |$index, $site| {
    file { "/etc/httpd/conf.d/${index}-${site['domain']}.conf":
      content => template('httpd/virtual_host.conf.erb'),
      notify  => Service['httpd'],
      require => File['/etc/httpd/conf.d'],
    }
  }
    </pre>
  </div>
</section>
<section id="best-practices">
  <h4><a href="#best-practices">Best Practices</a></h4>
  <h5>Puppet-Lint</h5>
  <p>
    Puppet has a set standard for formatting module files and there's a gem to help you follow that standard.
  </p>
  <div class="snippet one-line">
    <pre>gem install puppet-lint</pre>
  </div>
  <p>
    This will install puppet-lint and then you can run it in your module directory with <span class="command">puppet-lint</span> to see (and fix) any standardization issues.
  </p>
  <h5>Revision Control (git)</h5>
  <p>
    Revision Control Your Configurations!
  </p>
  <p>
    The best part, to me, about Puppet is that it lets me see how I last left my servers configured. If you implement revision control with git then you can also see where they've been over time and make it easy to rollback any changes.
  </p>
</section>
<section id="next">
  <h4><a href="#next">Next</a></h4>
  <p>Run <a href="/puppet-5/example/">an example</a></p>
</section>
{% endblock %}
